'''
구현 못함
'''
# 풀이 컨셉
# 2n+1 * 2n+1 크기의 행렬을 만듦
# n은 각 행 또는 열에 들어있는 S, L, R의 수
# S,L,R을 감싸는 형태로 행렬이 만들어짐
# 우리가 지정한 값보다 크거나 작은 경우
# 즉 행렬에서 행 또는 열이 0이되거나 2n이 될 경우
# 이는 우리가 생각하는 좌표를 벗어난 것이므로
# 행렬에서 초과하는 행 또는 열 값을 0 -> 2n, 2n -> 0으로 바꿔주면 됨

# 고려사항
# 1. 사이클 확인 필요
# - 사이클이 존재하는지 확인하는 방법이 뭐가있더라?
# - 사이클이 존재하지 않는다면 다른 방향에서 빛을 쏠 수 있도록 구현해야함
# - 다른 방향에서 쏴서 사이클이 만들어진다면 그 사이클이 정답값에 저장되어야함
# - 방문 처리로 사이클 확인
# - 들어오는거랑 나가는 방문을 구분해서 저장해야되는데?
# - out check와 in check list를 각각 만들어야하나?

# 2. 빛이 경계를 넘어갈 경우 구현
# - 넘어갈 경우 행 값이나 열 값 중 넘어가는 값만 최소값으로 변경해주면 될듯
# - 예를 들어 [2,2]에서 [2,3]이 되면 [2,0]으로 넘겨주도록

# 3. 회전 구현
# 직진, 회전 등을 어떻게 구현하면 좋을까?
# - 직진
# dx = [1,1,0,0]?
# nx = x + dx[i]

# - 좌회전, 우회전
# dx = [0,0,-1,0] ? -> 진입 방향을 어떻게 잡아줄 것인가?
# dy = []
# 진입 방향에 따라 회전을 어떻게 시킬지?

# 4. 정답 출력
# list array로 한번에 출력해야됨
# while 돌면서 while 다 돌면 출력되도록 해야하나?
    
from collections import deque

def bfs(n):
    
    # cycle check
    
    # visited check
    queue = deque[]
    map = [[0] * (2*n+1) for _ in range(2*n+1)]
    visitedIN = 
    visitedOUT = 
    

    # while -> S, L, R
    while queue:
    
    
        if n[x][y] == 'S':
        
# ---
def solution(grid):
    answer = []
    n = len(grid)
    answer.append(bfs(n))
    return answer
